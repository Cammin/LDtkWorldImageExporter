// <auto-generated />
//
// To parse this JSON data, get Utf8Json then do:
//
//    using LDtkUnity;
//
//    var ldtkJson = LdtkJson.FromJson(jsonString);

namespace WorldImageMerger
{
    using System;
    using System.Collections.Generic;

    using Utf8Json;
    using System.Runtime.Serialization;

    /// <summary>
    /// This file is a JSON schema of files created by LDtk level editor (https://ldtk.io).
    ///
    /// This is the root of any Project JSON file. It contains:  - the project settings, - an
    /// array of levels, - a group of definitions (that can probably be safely ignored for most
    /// users).
    /// </summary>
    public partial class LdtkJson
    {
        /// <summary>
        /// This object is not actually used by LDtk. It ONLY exists to force explicit references to
        /// all types, to make sure QuickType finds them and integrate all of them. Otherwise,
        /// Quicktype will drop types that are not explicitely used.
        /// </summary>
        [IgnoreDataMember]
        [DataMember(Name = "__FORCED_REFS")]
        public ForcedRefs ForcedRefs { get; set; }

        /// <summary>
        /// LDtk application build identifier.<br/>  This is only used to identify the LDtk version
        /// that generated this particular project file, which can be useful for specific bug fixing.
        /// Note that the build identifier is just the date of the release, so it's not unique to
        /// each user (one single global ID per LDtk public release), and as a result, completely
        /// anonymous.
        /// </summary>
        [DataMember(Name = "appBuildId")]
        public float AppBuildId { get; set; }

        /// <summary>
        /// Number of backup files to keep, if the `backupOnSave` is TRUE
        /// </summary>
        [DataMember(Name = "backupLimit")]
        public int BackupLimit { get; set; }

        /// <summary>
        /// If TRUE, an extra copy of the project will be created in a sub folder, when saving.
        /// </summary>
        [DataMember(Name = "backupOnSave")]
        public bool BackupOnSave { get; set; }

        /// <summary>
        /// Target relative path to store backup files
        /// </summary>
        [DataMember(Name = "backupRelPath")]
        public string BackupRelPath { get; set; }

        /// <summary>
        /// Project background color
        /// </summary>
        [DataMember(Name = "bgColor")]
        public string BgColor { get; set; }

        /// <summary>
        /// An array of command lines that can be ran manually by the user
        /// </summary>
        [DataMember(Name = "customCommands")]
        public LdtkCustomCommand[] CustomCommands { get; set; }

        /// <summary>
        /// Default height for new entities
        /// </summary>
        [DataMember(Name = "defaultEntityHeight")]
        public int DefaultEntityHeight { get; set; }

        /// <summary>
        /// Default width for new entities
        /// </summary>
        [DataMember(Name = "defaultEntityWidth")]
        public int DefaultEntityWidth { get; set; }

        /// <summary>
        /// Default grid size for new layers
        /// </summary>
        [DataMember(Name = "defaultGridSize")]
        public int DefaultGridSize { get; set; }

        /// <summary>
        /// Default background color of levels
        /// </summary>
        [DataMember(Name = "defaultLevelBgColor")]
        public string DefaultLevelBgColor { get; set; }

        /// <summary>
        /// **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
        /// It will then be `null`. You can enable the Multi-worlds advanced project option to enable
        /// the change immediately.<br/><br/>  Default new level height
        /// </summary>
        [DataMember(Name = "defaultLevelHeight")]
        public int? DefaultLevelHeight { get; set; }

        /// <summary>
        /// **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
        /// It will then be `null`. You can enable the Multi-worlds advanced project option to enable
        /// the change immediately.<br/><br/>  Default new level width
        /// </summary>
        [DataMember(Name = "defaultLevelWidth")]
        public int? DefaultLevelWidth { get; set; }

        /// <summary>
        /// Default X pivot (0 to 1) for new entities
        /// </summary>
        [DataMember(Name = "defaultPivotX")]
        public float DefaultPivotX { get; set; }

        /// <summary>
        /// Default Y pivot (0 to 1) for new entities
        /// </summary>
        [DataMember(Name = "defaultPivotY")]
        public float DefaultPivotY { get; set; }

        /// <summary>
        /// A structure containing all the definitions of this project
        /// </summary>
        [DataMember(Name = "defs")]
        public Definitions Defs { get; set; }

        /// <summary>
        /// If the project isn't in MultiWorlds mode, this is the IID of the internal "dummy" World.
        /// </summary>
        [DataMember(Name = "dummyWorldIid")]
        public string DummyWorldIid { get; set; }

        /// <summary>
        /// If TRUE, the exported PNGs will include the level background (color or image).
        /// </summary>
        [DataMember(Name = "exportLevelBg")]
        public bool ExportLevelBg { get; set; }

        /// <summary>
        /// **WARNING**: this deprecated value is no longer exported since version 0.9.3  Replaced
        /// by: `imageExportMode`
        /// </summary>
        [DataMember(Name = "exportPng")]
        public bool? ExportPng { get; set; }

        /// <summary>
        /// If TRUE, a Tiled compatible file will also be generated along with the LDtk JSON file
        /// (default is FALSE)
        /// </summary>
        [DataMember(Name = "exportTiled")]
        public bool ExportTiled { get; set; }

        /// <summary>
        /// If TRUE, one file will be saved for the project (incl. all its definitions) and one file
        /// in a sub-folder for each level.
        /// </summary>
        [DataMember(Name = "externalLevels")]
        public bool ExternalLevels { get; set; }

        /// <summary>
        /// An array containing various advanced flags (ie. options or other states). Possible
        /// values: `DiscardPreCsvIntGrid`, `ExportOldTableOfContentData`,
        /// `ExportPreCsvIntGridFormat`, `IgnoreBackupSuggest`, `PrependIndexToLevelFileNames`,
        /// `MultiWorlds`, `UseMultilinesType`
        /// </summary>
        [DataMember(Name = "flags")]
        public Flag[] Flags { get; set; }

        /// <summary>
        /// Naming convention for Identifiers (first-letter uppercase, full uppercase etc.) Possible
        /// values: `Capitalize`, `Uppercase`, `Lowercase`, `Free`
        /// </summary>
        [DataMember(Name = "identifierStyle")]
        public IdentifierStyle IdentifierStyle { get; set; }

        /// <summary>
        /// Unique project identifier
        /// </summary>
        [DataMember(Name = "iid")]
        public string Iid { get; set; }

        /// <summary>
        /// "Image export" option when saving project. Possible values: `None`, `OneImagePerLayer`,
        /// `OneImagePerLevel`, `LayersAndLevels`
        /// </summary>
        [DataMember(Name = "imageExportMode")]
        public ImageExportMode ImageExportMode { get; set; }

        /// <summary>
        /// File format version
        /// </summary>
        [DataMember(Name = "jsonVersion")]
        public string JsonVersion { get; set; }

        /// <summary>
        /// The default naming convention for level identifiers.
        /// </summary>
        [DataMember(Name = "levelNamePattern")]
        public string LevelNamePattern { get; set; }

        /// <summary>
        /// All levels. The order of this array is only relevant in `LinearHorizontal` and
        /// `linearVertical` world layouts (see `worldLayout` value).<br/>  Otherwise, you should
        /// refer to the `worldX`,`worldY` coordinates of each Level.
        /// </summary>
        [DataMember(Name = "levels")]
        public Level[] Levels { get; set; }

        /// <summary>
        /// If TRUE, the Json is partially minified (no indentation, nor line breaks, default is
        /// FALSE)
        /// </summary>
        [DataMember(Name = "minifyJson")]
        public bool MinifyJson { get; set; }

        /// <summary>
        /// Next Unique integer ID available
        /// </summary>
        [DataMember(Name = "nextUid")]
        public int NextUid { get; set; }

        /// <summary>
        /// File naming pattern for exported PNGs
        /// </summary>
        [DataMember(Name = "pngFilePattern")]
        public string PngFilePattern { get; set; }

        /// <summary>
        /// If TRUE, a very simplified will be generated on saving, for quicker & easier engine
        /// integration.
        /// </summary>
        [DataMember(Name = "simplifiedExport")]
        public bool SimplifiedExport { get; set; }

        /// <summary>
        /// All instances of entities that have their `exportToToc` flag enabled are listed in this
        /// array.
        /// </summary>
        [DataMember(Name = "toc")]
        public LdtkTableOfContentEntry[] Toc { get; set; }

        /// <summary>
        /// This optional description is used by LDtk Samples to show up some informations and
        /// instructions.
        /// </summary>
        [DataMember(Name = "tutorialDesc")]
        public string TutorialDesc { get; set; }

        /// <summary>
        /// **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
        /// It will then be `null`. You can enable the Multi-worlds advanced project option to enable
        /// the change immediately.<br/><br/>  Height of the world grid in pixels.
        /// </summary>
        [DataMember(Name = "worldGridHeight")]
        public int? WorldGridHeight { get; set; }

        /// <summary>
        /// **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
        /// It will then be `null`. You can enable the Multi-worlds advanced project option to enable
        /// the change immediately.<br/><br/>  Width of the world grid in pixels.
        /// </summary>
        [DataMember(Name = "worldGridWidth")]
        public int? WorldGridWidth { get; set; }

        /// <summary>
        /// **WARNING**: this field will move to the `worlds` array after the "multi-worlds" update.
        /// It will then be `null`. You can enable the Multi-worlds advanced project option to enable
        /// the change immediately.<br/><br/>  An enum that describes how levels are organized in
        /// this project (ie. linearly or in a 2D space). Possible values: &lt;`null`&gt;, `Free`,
        /// `GridVania`, `LinearHorizontal`, `LinearVertical`
        /// </summary>
        [DataMember(Name = "worldLayout")]
        public WorldLayout? WorldLayout { get; set; }

        /// <summary>
        /// This array will be empty, unless you enable the Multi-Worlds in the project advanced
        /// settings.<br/><br/> - in current version, a LDtk project file can only contain a single
        /// world with multiple levels in it. In this case, levels and world layout related settings
        /// are stored in the root of the JSON.<br/> - with "Multi-worlds" enabled, there will be a
        /// `worlds` array in root, each world containing levels and layout settings. Basically, it's
        /// pretty much only about moving the `levels` array to the `worlds` array, along with world
        /// layout related values (eg. `worldGridWidth` etc).<br/><br/>If you want to start
        /// supporting this future update easily, please refer to this documentation:
        /// https://github.com/deepnight/ldtk/issues/231
        /// </summary>
        [DataMember(Name = "worlds")]
        public World[] Worlds { get; set; }
    }

    public partial class LdtkCustomCommand
    {
        [DataMember(Name = "command")]
        public string Command { get; set; }

        /// <summary>
        /// Possible values: `Manual`, `AfterLoad`, `BeforeSave`, `AfterSave`
        /// </summary>
        [DataMember(Name = "when")]
        public When When { get; set; }
    }

    /// <summary>
    /// If you're writing your own LDtk importer, you should probably just ignore *most* stuff in
    /// the `defs` section, as it contains data that are mostly important to the editor. To keep
    /// you away from the `defs` section and avoid some unnecessary JSON parsing, important data
    /// from definitions is often duplicated in fields prefixed with a double underscore (eg.
    /// `__identifier` or `__type`).  The 2 only definition types you might need here are
    /// **Tilesets** and **Enums**.
    ///
    /// A structure containing all the definitions of this project
    /// </summary>
    public partial class Definitions
    {
        /// <summary>
        /// All entities definitions, including their custom fields
        /// </summary>
        [DataMember(Name = "entities")]
        public EntityDefinition[] Entities { get; set; }

        /// <summary>
        /// All internal enums
        /// </summary>
        [DataMember(Name = "enums")]
        public EnumDefinition[] Enums { get; set; }

        /// <summary>
        /// Note: external enums are exactly the same as `enums`, except they have a `relPath` to
        /// point to an external source file.
        /// </summary>
        [DataMember(Name = "externalEnums")]
        public EnumDefinition[] ExternalEnums { get; set; }

        /// <summary>
        /// All layer definitions
        /// </summary>
        [DataMember(Name = "layers")]
        public LayerDefinition[] Layers { get; set; }

        /// <summary>
        /// All custom fields available to all levels.
        /// </summary>
        [DataMember(Name = "levelFields")]
        public FieldDefinition[] LevelFields { get; set; }

        /// <summary>
        /// All tilesets
        /// </summary>
        [DataMember(Name = "tilesets")]
        public TilesetDefinition[] Tilesets { get; set; }
    }

    public partial class EntityDefinition
    {
        /// <summary>
        /// If enabled, this entity is allowed to stay outside of the current level bounds
        /// </summary>
        [DataMember(Name = "allowOutOfBounds")]
        public bool AllowOutOfBounds { get; set; }

        /// <summary>
        /// Base entity color
        /// </summary>
        [DataMember(Name = "color")]
        public string Color { get; set; }

        /// <summary>
        /// User defined documentation for this element to provide help/tips to level designers.
        /// </summary>
        [DataMember(Name = "doc")]
        public string Doc { get; set; }

        /// <summary>
        /// If enabled, all instances of this entity will be listed in the project "Table of content"
        /// object.
        /// </summary>
        [DataMember(Name = "exportToToc")]
        public bool ExportToToc { get; set; }

        /// <summary>
        /// Array of field definitions
        /// </summary>
        [DataMember(Name = "fieldDefs")]
        public FieldDefinition[] FieldDefs { get; set; }

        [DataMember(Name = "fillOpacity")]
        public float FillOpacity { get; set; }

        /// <summary>
        /// Pixel height
        /// </summary>
        [DataMember(Name = "height")]
        public int Height { get; set; }

        [DataMember(Name = "hollow")]
        public bool Hollow { get; set; }

        /// <summary>
        /// User defined unique identifier
        /// </summary>
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Only applies to entities resizable on both X/Y. If TRUE, the entity instance width/height
        /// will keep the same aspect ratio as the definition.
        /// </summary>
        [DataMember(Name = "keepAspectRatio")]
        public bool KeepAspectRatio { get; set; }

        /// <summary>
        /// Possible values: `DiscardOldOnes`, `PreventAdding`, `MoveLastOne`
        /// </summary>
        [DataMember(Name = "limitBehavior")]
        public LimitBehavior LimitBehavior { get; set; }

        /// <summary>
        /// If TRUE, the maxCount is a "per world" limit, if FALSE, it's a "per level". Possible
        /// values: `PerLayer`, `PerLevel`, `PerWorld`
        /// </summary>
        [DataMember(Name = "limitScope")]
        public LimitScope LimitScope { get; set; }

        [DataMember(Name = "lineOpacity")]
        public float LineOpacity { get; set; }

        /// <summary>
        /// Max instances count
        /// </summary>
        [DataMember(Name = "maxCount")]
        public int MaxCount { get; set; }

        /// <summary>
        /// Max pixel height (only applies if the entity is resizable on Y)
        /// </summary>
        [DataMember(Name = "maxHeight")]
        public int? MaxHeight { get; set; }

        /// <summary>
        /// Max pixel width (only applies if the entity is resizable on X)
        /// </summary>
        [DataMember(Name = "maxWidth")]
        public int? MaxWidth { get; set; }

        /// <summary>
        /// Min pixel height (only applies if the entity is resizable on Y)
        /// </summary>
        [DataMember(Name = "minHeight")]
        public int? MinHeight { get; set; }

        /// <summary>
        /// Min pixel width (only applies if the entity is resizable on X)
        /// </summary>
        [DataMember(Name = "minWidth")]
        public int? MinWidth { get; set; }

        /// <summary>
        /// An array of 4 dimensions for the up/right/down/left borders (in this order) when using
        /// 9-slice mode for `tileRenderMode`.<br/>  If the tileRenderMode is not NineSlice, then
        /// this array is empty.<br/>  See: https://en.wikipedia.org/wiki/9-slice_scaling
        /// </summary>
        [DataMember(Name = "nineSliceBorders")]
        public int[] NineSliceBorders { get; set; }

        /// <summary>
        /// Pivot X coordinate (from 0 to 1.0)
        /// </summary>
        [DataMember(Name = "pivotX")]
        public float PivotX { get; set; }

        /// <summary>
        /// Pivot Y coordinate (from 0 to 1.0)
        /// </summary>
        [DataMember(Name = "pivotY")]
        public float PivotY { get; set; }

        /// <summary>
        /// Possible values: `Rectangle`, `Ellipse`, `Tile`, `Cross`
        /// </summary>
        [DataMember(Name = "renderMode")]
        public RenderMode RenderMode { get; set; }

        /// <summary>
        /// If TRUE, the entity instances will be resizable horizontally
        /// </summary>
        [DataMember(Name = "resizableX")]
        public bool ResizableX { get; set; }

        /// <summary>
        /// If TRUE, the entity instances will be resizable vertically
        /// </summary>
        [DataMember(Name = "resizableY")]
        public bool ResizableY { get; set; }

        /// <summary>
        /// Display entity name in editor
        /// </summary>
        [DataMember(Name = "showName")]
        public bool ShowName { get; set; }

        /// <summary>
        /// An array of strings that classifies this entity
        /// </summary>
        [DataMember(Name = "tags")]
        public string[] Tags { get; set; }

        /// <summary>
        /// **WARNING**: this deprecated value is no longer exported since version 1.2.0  Replaced
        /// by: `tileRect`
        /// </summary>
        [DataMember(Name = "tileId")]
        public int? TileId { get; set; }

        [DataMember(Name = "tileOpacity")]
        public float TileOpacity { get; set; }

        /// <summary>
        /// An object representing a rectangle from an existing Tileset
        /// </summary>
        [DataMember(Name = "tileRect")]
        public TilesetRectangle TileRect { get; set; }

        /// <summary>
        /// An enum describing how the the Entity tile is rendered inside the Entity bounds. Possible
        /// values: `Cover`, `FitInside`, `Repeat`, `Stretch`, `FullSizeCropped`,
        /// `FullSizeUncropped`, `NineSlice`
        /// </summary>
        [DataMember(Name = "tileRenderMode")]
        public TileRenderMode TileRenderMode { get; set; }

        /// <summary>
        /// Tileset ID used for optional tile display
        /// </summary>
        [DataMember(Name = "tilesetId")]
        public int? TilesetId { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [DataMember(Name = "uid")]
        public int Uid { get; set; }

        /// <summary>
        /// This tile overrides the one defined in `tileRect` in the UI
        /// </summary>
        [DataMember(Name = "uiTileRect")]
        public TilesetRectangle UiTileRect { get; set; }

        /// <summary>
        /// Pixel width
        /// </summary>
        [DataMember(Name = "width")]
        public int Width { get; set; }
    }

    /// <summary>
    /// This section is mostly only intended for the LDtk editor app itself. You can safely
    /// ignore it.
    /// </summary>
    public partial class FieldDefinition
    {
        /// <summary>
        /// Human readable value type. Possible values: `Int, Float, String, Bool, Color,
        /// ExternEnum.XXX, LocalEnum.XXX, Point, FilePath`.<br/>  If the field is an array, this
        /// field will look like `Array<...>` (eg. `Array<Int>`, `Array<Point>` etc.)<br/>  NOTE: if
        /// you enable the advanced option **Use Multilines type**, you will have "*Multilines*"
        /// instead of "*String*" when relevant.
        /// </summary>
        [DataMember(Name = "__type")]
        public string Type { get; set; }

        /// <summary>
        /// Optional list of accepted file extensions for FilePath value type. Includes the dot:
        /// `.ext`
        /// </summary>
        [DataMember(Name = "acceptFileTypes")]
        public string[] AcceptFileTypes { get; set; }

        /// <summary>
        /// Possible values: `Any`, `OnlySame`, `OnlyTags`, `OnlySpecificEntity`
        /// </summary>
        [DataMember(Name = "allowedRefs")]
        public AllowedRefs AllowedRefs { get; set; }

        [DataMember(Name = "allowedRefsEntityUid")]
        public int? AllowedRefsEntityUid { get; set; }

        [DataMember(Name = "allowedRefTags")]
        public string[] AllowedRefTags { get; set; }

        [DataMember(Name = "allowOutOfLevelRef")]
        public bool AllowOutOfLevelRef { get; set; }

        /// <summary>
        /// Array max length
        /// </summary>
        [DataMember(Name = "arrayMaxLength")]
        public int? ArrayMaxLength { get; set; }

        /// <summary>
        /// Array min length
        /// </summary>
        [DataMember(Name = "arrayMinLength")]
        public int? ArrayMinLength { get; set; }

        [DataMember(Name = "autoChainRef")]
        public bool AutoChainRef { get; set; }

        /// <summary>
        /// TRUE if the value can be null. For arrays, TRUE means it can contain null values
        /// (exception: array of Points can't have null values).
        /// </summary>
        [DataMember(Name = "canBeNull")]
        public bool CanBeNull { get; set; }

        /// <summary>
        /// Default value if selected value is null or invalid.
        /// </summary>
        [DataMember(Name = "defaultOverride")]
        public object DefaultOverride { get; set; }

        /// <summary>
        /// User defined documentation for this field to provide help/tips to level designers about
        /// accepted values.
        /// </summary>
        [DataMember(Name = "doc")]
        public string Doc { get; set; }

        [DataMember(Name = "editorAlwaysShow")]
        public bool EditorAlwaysShow { get; set; }

        [DataMember(Name = "editorCutLongValues")]
        public bool EditorCutLongValues { get; set; }

        [DataMember(Name = "editorDisplayColor")]
        public string EditorDisplayColor { get; set; }

        /// <summary>
        /// Possible values: `Hidden`, `ValueOnly`, `NameAndValue`, `EntityTile`, `LevelTile`,
        /// `Points`, `PointStar`, `PointPath`, `PointPathLoop`, `RadiusPx`, `RadiusGrid`,
        /// `ArrayCountWithLabel`, `ArrayCountNoLabel`, `RefLinkBetweenPivots`,
        /// `RefLinkBetweenCenters`
        /// </summary>
        [DataMember(Name = "editorDisplayMode")]
        public EditorDisplayMode EditorDisplayMode { get; set; }

        /// <summary>
        /// Possible values: `Above`, `Center`, `Beneath`
        /// </summary>
        [DataMember(Name = "editorDisplayPos")]
        public EditorDisplayPos EditorDisplayPos { get; set; }

        [DataMember(Name = "editorDisplayScale")]
        public float EditorDisplayScale { get; set; }

        /// <summary>
        /// Possible values: `ZigZag`, `StraightArrow`, `CurvedArrow`, `ArrowsLine`, `DashedLine`
        /// </summary>
        [DataMember(Name = "editorLinkStyle")]
        public EditorLinkStyle EditorLinkStyle { get; set; }

        [DataMember(Name = "editorShowInWorld")]
        public bool EditorShowInWorld { get; set; }

        [DataMember(Name = "editorTextPrefix")]
        public string EditorTextPrefix { get; set; }

        [DataMember(Name = "editorTextSuffix")]
        public string EditorTextSuffix { get; set; }

        /// <summary>
        /// If TRUE, the field value will be exported to the `toc` project JSON field. Only applies
        /// to Entity fields.
        /// </summary>
        [DataMember(Name = "exportToToc")]
        public bool ExportToToc { get; set; }

        /// <summary>
        /// User defined unique identifier
        /// </summary>
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// TRUE if the value is an array of multiple values
        /// </summary>
        [DataMember(Name = "isArray")]
        public bool IsArray { get; set; }

        /// <summary>
        /// Max limit for value, if applicable
        /// </summary>
        [DataMember(Name = "max")]
        public float? Max { get; set; }

        /// <summary>
        /// Min limit for value, if applicable
        /// </summary>
        [DataMember(Name = "min")]
        public float? Min { get; set; }

        /// <summary>
        /// Optional regular expression that needs to be matched to accept values. Expected format:
        /// `/some_reg_ex/g`, with optional "i" flag.
        /// </summary>
        [DataMember(Name = "regex")]
        public string Regex { get; set; }

        /// <summary>
        /// If enabled, this field will be searchable through LDtk command palette
        /// </summary>
        [DataMember(Name = "searchable")]
        public bool Searchable { get; set; }

        [DataMember(Name = "symmetricalRef")]
        public bool SymmetricalRef { get; set; }

        /// <summary>
        /// Possible values: &lt;`null`&gt;, `LangPython`, `LangRuby`, `LangJS`, `LangLua`, `LangC`,
        /// `LangHaxe`, `LangMarkdown`, `LangJson`, `LangXml`, `LangLog`
        /// </summary>
        [DataMember(Name = "textLanguageMode")]
        public TextLanguageMode? TextLanguageMode { get; set; }

        /// <summary>
        /// UID of the tileset used for a Tile
        /// </summary>
        [DataMember(Name = "tilesetUid")]
        public int? TilesetUid { get; set; }

        /// <summary>
        /// Internal enum representing the possible field types. Possible values: F_Int, F_Float,
        /// F_String, F_Text, F_Bool, F_Color, F_Enum(...), F_Point, F_Path, F_EntityRef, F_Tile
        /// </summary>
        [DataMember(Name = "type")]
        public string FieldDefinitionType { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [DataMember(Name = "uid")]
        public int Uid { get; set; }

        /// <summary>
        /// If TRUE, the color associated with this field will override the Entity or Level default
        /// color in the editor UI. For Enum fields, this would be the color associated to their
        /// values.
        /// </summary>
        [DataMember(Name = "useForSmartColor")]
        public bool UseForSmartColor { get; set; }
    }

    /// <summary>
    /// This object represents a custom sub rectangle in a Tileset image.
    /// </summary>
    public partial class TilesetRectangle
    {
        /// <summary>
        /// Height in pixels
        /// </summary>
        [DataMember(Name = "h")]
        public int H { get; set; }

        /// <summary>
        /// UID of the tileset
        /// </summary>
        [DataMember(Name = "tilesetUid")]
        public int TilesetUid { get; set; }

        /// <summary>
        /// Width in pixels
        /// </summary>
        [DataMember(Name = "w")]
        public int W { get; set; }

        /// <summary>
        /// X pixels coordinate of the top-left corner in the Tileset image
        /// </summary>
        [DataMember(Name = "x")]
        public int X { get; set; }

        /// <summary>
        /// Y pixels coordinate of the top-left corner in the Tileset image
        /// </summary>
        [DataMember(Name = "y")]
        public int Y { get; set; }
    }

    public partial class EnumDefinition
    {
        [DataMember(Name = "externalFileChecksum")]
        public string ExternalFileChecksum { get; set; }

        /// <summary>
        /// Relative path to the external file providing this Enum
        /// </summary>
        [DataMember(Name = "externalRelPath")]
        public string ExternalRelPath { get; set; }

        /// <summary>
        /// Tileset UID if provided
        /// </summary>
        [DataMember(Name = "iconTilesetUid")]
        public int? IconTilesetUid { get; set; }

        /// <summary>
        /// User defined unique identifier
        /// </summary>
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// An array of user-defined tags to organize the Enums
        /// </summary>
        [DataMember(Name = "tags")]
        public string[] Tags { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [DataMember(Name = "uid")]
        public int Uid { get; set; }

        /// <summary>
        /// All possible enum values, with their optional Tile infos.
        /// </summary>
        [DataMember(Name = "values")]
        public EnumValueDefinition[] Values { get; set; }
    }

    public partial class EnumValueDefinition
    {
        /// <summary>
        /// **WARNING**: this deprecated value is no longer exported since version 1.4.0  Replaced
        /// by: `tileRect`
        /// </summary>
        [DataMember(Name = "__tileSrcRect")]
        public int[] TileSrcRect { get; set; }

        /// <summary>
        /// Optional color
        /// </summary>
        [DataMember(Name = "color")]
        public int Color { get; set; }

        /// <summary>
        /// Enum value
        /// </summary>
        [DataMember(Name = "id")]
        public string Id { get; set; }

        /// <summary>
        /// **WARNING**: this deprecated value is no longer exported since version 1.4.0  Replaced
        /// by: `tileRect`
        /// </summary>
        [DataMember(Name = "tileId")]
        public int? TileId { get; set; }

        /// <summary>
        /// Optional tileset rectangle to represents this value
        /// </summary>
        [DataMember(Name = "tileRect")]
        public TilesetRectangle TileRect { get; set; }
    }

    public partial class LayerDefinition
    {
        /// <summary>
        /// Type of the layer (*IntGrid, Entities, Tiles or AutoLayer*)
        /// </summary>
        [DataMember(Name = "__type")]
        public string Type { get; set; }

        /// <summary>
        /// Contains all the auto-layer rule definitions.
        /// </summary>
        [DataMember(Name = "autoRuleGroups")]
        public AutoLayerRuleGroup[] AutoRuleGroups { get; set; }

        [DataMember(Name = "autoSourceLayerDefUid")]
        public int? AutoSourceLayerDefUid { get; set; }

        /// <summary>
        /// **WARNING**: this deprecated value is no longer exported since version 1.2.0  Replaced
        /// by: `tilesetDefUid`
        /// </summary>
        [DataMember(Name = "autoTilesetDefUid")]
        public int? AutoTilesetDefUid { get; set; }

        [DataMember(Name = "autoTilesKilledByOtherLayerUid")]
        public int? AutoTilesKilledByOtherLayerUid { get; set; }

        [DataMember(Name = "biomeFieldUid")]
        public int? BiomeFieldUid { get; set; }

        /// <summary>
        /// Allow editor selections when the layer is not currently active.
        /// </summary>
        [DataMember(Name = "canSelectWhenInactive")]
        public bool CanSelectWhenInactive { get; set; }

        /// <summary>
        /// Opacity of the layer (0 to 1.0)
        /// </summary>
        [DataMember(Name = "displayOpacity")]
        public float DisplayOpacity { get; set; }

        /// <summary>
        /// User defined documentation for this element to provide help/tips to level designers.
        /// </summary>
        [DataMember(Name = "doc")]
        public string Doc { get; set; }

        /// <summary>
        /// An array of tags to forbid some Entities in this layer
        /// </summary>
        [DataMember(Name = "excludedTags")]
        public string[] ExcludedTags { get; set; }

        /// <summary>
        /// Width and height of the grid in pixels
        /// </summary>
        [DataMember(Name = "gridSize")]
        public int GridSize { get; set; }

        /// <summary>
        /// Height of the optional "guide" grid in pixels
        /// </summary>
        [DataMember(Name = "guideGridHei")]
        public int GuideGridHei { get; set; }

        /// <summary>
        /// Width of the optional "guide" grid in pixels
        /// </summary>
        [DataMember(Name = "guideGridWid")]
        public int GuideGridWid { get; set; }

        [DataMember(Name = "hideFieldsWhenInactive")]
        public bool HideFieldsWhenInactive { get; set; }

        /// <summary>
        /// Hide the layer from the list on the side of the editor view.
        /// </summary>
        [DataMember(Name = "hideInList")]
        public bool HideInList { get; set; }

        /// <summary>
        /// User defined unique identifier
        /// </summary>
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Alpha of this layer when it is not the active one.
        /// </summary>
        [DataMember(Name = "inactiveOpacity")]
        public float InactiveOpacity { get; set; }

        /// <summary>
        /// An array that defines extra optional info for each IntGrid value.<br/>  WARNING: the
        /// array order is not related to actual IntGrid values! As user can re-order IntGrid values
        /// freely, you may value "2" before value "1" in this array.
        /// </summary>
        [DataMember(Name = "intGridValues")]
        public IntGridValueDefinition[] IntGridValues { get; set; }

        /// <summary>
        /// Group informations for IntGrid values
        /// </summary>
        [DataMember(Name = "intGridValuesGroups")]
        public IntGridValueGroupDefinition[] IntGridValuesGroups { get; set; }

        /// <summary>
        /// Parallax horizontal factor (from -1 to 1, defaults to 0) which affects the scrolling
        /// speed of this layer, creating a fake 3D (parallax) effect.
        /// </summary>
        [DataMember(Name = "parallaxFactorX")]
        public float ParallaxFactorX { get; set; }

        /// <summary>
        /// Parallax vertical factor (from -1 to 1, defaults to 0) which affects the scrolling speed
        /// of this layer, creating a fake 3D (parallax) effect.
        /// </summary>
        [DataMember(Name = "parallaxFactorY")]
        public float ParallaxFactorY { get; set; }

        /// <summary>
        /// If true (default), a layer with a parallax factor will also be scaled up/down accordingly.
        /// </summary>
        [DataMember(Name = "parallaxScaling")]
        public bool ParallaxScaling { get; set; }

        /// <summary>
        /// X offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance`
        /// optional offset)
        /// </summary>
        [DataMember(Name = "pxOffsetX")]
        public int PxOffsetX { get; set; }

        /// <summary>
        /// Y offset of the layer, in pixels (IMPORTANT: this should be added to the `LayerInstance`
        /// optional offset)
        /// </summary>
        [DataMember(Name = "pxOffsetY")]
        public int PxOffsetY { get; set; }

        /// <summary>
        /// If TRUE, the content of this layer will be used when rendering levels in a simplified way
        /// for the world view
        /// </summary>
        [DataMember(Name = "renderInWorldView")]
        public bool RenderInWorldView { get; set; }

        /// <summary>
        /// An array of tags to filter Entities that can be added to this layer
        /// </summary>
        [DataMember(Name = "requiredTags")]
        public string[] RequiredTags { get; set; }

        /// <summary>
        /// If the tiles are smaller or larger than the layer grid, the pivot value will be used to
        /// position the tile relatively its grid cell.
        /// </summary>
        [DataMember(Name = "tilePivotX")]
        public float TilePivotX { get; set; }

        /// <summary>
        /// If the tiles are smaller or larger than the layer grid, the pivot value will be used to
        /// position the tile relatively its grid cell.
        /// </summary>
        [DataMember(Name = "tilePivotY")]
        public float TilePivotY { get; set; }

        /// <summary>
        /// Reference to the default Tileset UID being used by this layer definition.<br/>
        /// **WARNING**: some layer *instances* might use a different tileset. So most of the time,
        /// you should probably use the `__tilesetDefUid` value found in layer instances.<br/>  Note:
        /// since version 1.0.0, the old `autoTilesetDefUid` was removed and merged into this value.
        /// </summary>
        [DataMember(Name = "tilesetDefUid")]
        public int? TilesetDefUid { get; set; }

        /// <summary>
        /// Type of the layer as Haxe Enum Possible values: `IntGrid`, `Entities`, `Tiles`,
        /// `AutoLayer`
        /// </summary>
        [DataMember(Name = "type")]
        public TypeEnum LayerDefinitionType { get; set; }

        /// <summary>
        /// User defined color for the UI
        /// </summary>
        [DataMember(Name = "uiColor")]
        public string UiColor { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [DataMember(Name = "uid")]
        public int Uid { get; set; }

        /// <summary>
        /// Display tags
        /// </summary>
        [DataMember(Name = "uiFilterTags")]
        public string[] UiFilterTags { get; set; }

        /// <summary>
        /// Asynchronous rendering option for large/complex layers
        /// </summary>
        [DataMember(Name = "useAsyncRender")]
        public bool UseAsyncRender { get; set; }
    }

    public partial class AutoLayerRuleGroup
    {
        [DataMember(Name = "active")]
        public bool Active { get; set; }

        [DataMember(Name = "biomeRequirementMode")]
        public int BiomeRequirementMode { get; set; }

        /// <summary>
        /// *This field was removed in 1.0.0 and should no longer be used.*
        /// </summary>
        [DataMember(Name = "collapsed")]
        public bool? Collapsed { get; set; }

        [DataMember(Name = "color")]
        public string Color { get; set; }

        [DataMember(Name = "icon")]
        public TilesetRectangle Icon { get; set; }

        [DataMember(Name = "isOptional")]
        public bool IsOptional { get; set; }

        [DataMember(Name = "name")]
        public string Name { get; set; }

        [DataMember(Name = "requiredBiomeValues")]
        public string[] RequiredBiomeValues { get; set; }

        [DataMember(Name = "rules")]
        public AutoLayerRuleDefinition[] Rules { get; set; }

        [DataMember(Name = "uid")]
        public int Uid { get; set; }

        [DataMember(Name = "usesWizard")]
        public bool UsesWizard { get; set; }
    }

    /// <summary>
    /// This complex section isn't meant to be used by game devs at all, as these rules are
    /// completely resolved internally by the editor before any saving. You should just ignore
    /// this part.
    /// </summary>
    public partial class AutoLayerRuleDefinition
    {
        /// <summary>
        /// If FALSE, the rule effect isn't applied, and no tiles are generated.
        /// </summary>
        [DataMember(Name = "active")]
        public bool Active { get; set; }

        [DataMember(Name = "alpha")]
        public float Alpha { get; set; }

        /// <summary>
        /// When TRUE, the rule will prevent other rules to be applied in the same cell if it matches
        /// (TRUE by default).
        /// </summary>
        [DataMember(Name = "breakOnMatch")]
        public bool BreakOnMatch { get; set; }

        /// <summary>
        /// Chances for this rule to be applied (0 to 1)
        /// </summary>
        [DataMember(Name = "chance")]
        public float Chance { get; set; }

        /// <summary>
        /// Checker mode Possible values: `None`, `Horizontal`, `Vertical`
        /// </summary>
        [DataMember(Name = "checker")]
        public Checker Checker { get; set; }

        /// <summary>
        /// If TRUE, allow rule to be matched by flipping its pattern horizontally
        /// </summary>
        [DataMember(Name = "flipX")]
        public bool FlipX { get; set; }

        /// <summary>
        /// If TRUE, allow rule to be matched by flipping its pattern vertically
        /// </summary>
        [DataMember(Name = "flipY")]
        public bool FlipY { get; set; }

        /// <summary>
        /// If TRUE, then the rule should be re-evaluated by the editor at one point
        /// </summary>
        [DataMember(Name = "invalidated")]
        public bool Invalidated { get; set; }

        /// <summary>
        /// Default IntGrid value when checking cells outside of level bounds
        /// </summary>
        [DataMember(Name = "outOfBoundsValue")]
        public int? OutOfBoundsValue { get; set; }

        /// <summary>
        /// Rule pattern (size x size)
        /// </summary>
        [DataMember(Name = "pattern")]
        public int[] Pattern { get; set; }

        /// <summary>
        /// If TRUE, enable Perlin filtering to only apply rule on specific random area
        /// </summary>
        [DataMember(Name = "perlinActive")]
        public bool PerlinActive { get; set; }

        [DataMember(Name = "perlinOctaves")]
        public float PerlinOctaves { get; set; }

        [DataMember(Name = "perlinScale")]
        public float PerlinScale { get; set; }

        [DataMember(Name = "perlinSeed")]
        public float PerlinSeed { get; set; }

        /// <summary>
        /// X pivot of a tile stamp (0-1)
        /// </summary>
        [DataMember(Name = "pivotX")]
        public float PivotX { get; set; }

        /// <summary>
        /// Y pivot of a tile stamp (0-1)
        /// </summary>
        [DataMember(Name = "pivotY")]
        public float PivotY { get; set; }

        /// <summary>
        /// Pattern width & height. Should only be 1,3,5 or 7.
        /// </summary>
        [DataMember(Name = "size")]
        public int Size { get; set; }

        /// <summary>
        /// **WARNING**: this deprecated value is no longer exported since version 1.5.0  Replaced
        /// by: `tileRectsIds`
        /// </summary>
        [DataMember(Name = "tileIds")]
        public int[] TileIds { get; set; }

        /// <summary>
        /// Defines how tileIds array is used Possible values: `Single`, `Stamp`
        /// </summary>
        [DataMember(Name = "tileMode")]
        public TileMode TileMode { get; set; }

        /// <summary>
        /// Max random offset for X tile pos
        /// </summary>
        [DataMember(Name = "tileRandomXMax")]
        public int TileRandomXMax { get; set; }

        /// <summary>
        /// Min random offset for X tile pos
        /// </summary>
        [DataMember(Name = "tileRandomXMin")]
        public int TileRandomXMin { get; set; }

        /// <summary>
        /// Max random offset for Y tile pos
        /// </summary>
        [DataMember(Name = "tileRandomYMax")]
        public int TileRandomYMax { get; set; }

        /// <summary>
        /// Min random offset for Y tile pos
        /// </summary>
        [DataMember(Name = "tileRandomYMin")]
        public int TileRandomYMin { get; set; }

        /// <summary>
        /// Array containing all the possible tile IDs rectangles (picked randomly).
        /// </summary>
        [DataMember(Name = "tileRectsIds")]
        public int[][] TileRectsIds { get; set; }

        /// <summary>
        /// Tile X offset
        /// </summary>
        [DataMember(Name = "tileXOffset")]
        public int TileXOffset { get; set; }

        /// <summary>
        /// Tile Y offset
        /// </summary>
        [DataMember(Name = "tileYOffset")]
        public int TileYOffset { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [DataMember(Name = "uid")]
        public int Uid { get; set; }

        /// <summary>
        /// X cell coord modulo
        /// </summary>
        [DataMember(Name = "xModulo")]
        public int XModulo { get; set; }

        /// <summary>
        /// X cell start offset
        /// </summary>
        [DataMember(Name = "xOffset")]
        public int XOffset { get; set; }

        /// <summary>
        /// Y cell coord modulo
        /// </summary>
        [DataMember(Name = "yModulo")]
        public int YModulo { get; set; }

        /// <summary>
        /// Y cell start offset
        /// </summary>
        [DataMember(Name = "yOffset")]
        public int YOffset { get; set; }
    }

    /// <summary>
    /// IntGrid value definition
    /// </summary>
    public partial class IntGridValueDefinition
    {
        [DataMember(Name = "color")]
        public string Color { get; set; }

        /// <summary>
        /// Parent group identifier (0 if none)
        /// </summary>
        [DataMember(Name = "groupUid")]
        public int GroupUid { get; set; }

        /// <summary>
        /// User defined unique identifier
        /// </summary>
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        [DataMember(Name = "tile")]
        public TilesetRectangle Tile { get; set; }

        /// <summary>
        /// The IntGrid value itself
        /// </summary>
        [DataMember(Name = "value")]
        public int Value { get; set; }
    }

    /// <summary>
    /// IntGrid value group definition
    /// </summary>
    public partial class IntGridValueGroupDefinition
    {
        /// <summary>
        /// User defined color
        /// </summary>
        [DataMember(Name = "color")]
        public string Color { get; set; }

        /// <summary>
        /// User defined string identifier
        /// </summary>
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Group unique ID
        /// </summary>
        [DataMember(Name = "uid")]
        public int Uid { get; set; }
    }

    /// <summary>
    /// The `Tileset` definition is the most important part among project definitions. It
    /// contains some extra informations about each integrated tileset. If you only had to parse
    /// one definition section, that would be the one.
    /// </summary>
    public partial class TilesetDefinition
    {
        /// <summary>
        /// Grid-based height
        /// </summary>
        [DataMember(Name = "__cHei")]
        public int CHei { get; set; }

        /// <summary>
        /// Grid-based width
        /// </summary>
        [DataMember(Name = "__cWid")]
        public int CWid { get; set; }

        /// <summary>
        /// The following data is used internally for various optimizations. It's always synced with
        /// source image changes.
        /// </summary>
        [DataMember(Name = "cachedPixelData")]
        public System.Collections.Generic.Dictionary<string, object> CachedPixelData { get; set; }

        /// <summary>
        /// An array of custom tile metadata
        /// </summary>
        [DataMember(Name = "customData")]
        public TileCustomMetadata[] CustomData { get; set; }

        /// <summary>
        /// If this value is set, then it means that this atlas uses an internal LDtk atlas image
        /// instead of a loaded one. Possible values: &lt;`null`&gt;, `LdtkIcons`
        /// </summary>
        [DataMember(Name = "embedAtlas")]
        public EmbedAtlas? EmbedAtlas { get; set; }

        /// <summary>
        /// Tileset tags using Enum values specified by `tagsSourceEnumId`. This array contains 1
        /// element per Enum value, which contains an array of all Tile IDs that are tagged with it.
        /// </summary>
        [DataMember(Name = "enumTags")]
        public EnumTagValue[] EnumTags { get; set; }

        /// <summary>
        /// User defined unique identifier
        /// </summary>
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Distance in pixels from image borders
        /// </summary>
        [DataMember(Name = "padding")]
        public int Padding { get; set; }

        /// <summary>
        /// Image height in pixels
        /// </summary>
        [DataMember(Name = "pxHei")]
        public int PxHei { get; set; }

        /// <summary>
        /// Image width in pixels
        /// </summary>
        [DataMember(Name = "pxWid")]
        public int PxWid { get; set; }

        /// <summary>
        /// Path to the source file, relative to the current project JSON file<br/>  It can be null
        /// if no image was provided, or when using an embed atlas.
        /// </summary>
        [DataMember(Name = "relPath")]
        public string RelPath { get; set; }

        /// <summary>
        /// Array of group of tiles selections, only meant to be used in the editor
        /// </summary>
        [DataMember(Name = "savedSelections")]
        public System.Collections.Generic.Dictionary<string, object>[] SavedSelections { get; set; }

        /// <summary>
        /// Space in pixels between all tiles
        /// </summary>
        [DataMember(Name = "spacing")]
        public int Spacing { get; set; }

        /// <summary>
        /// An array of user-defined tags to organize the Tilesets
        /// </summary>
        [DataMember(Name = "tags")]
        public string[] Tags { get; set; }

        /// <summary>
        /// Optional Enum definition UID used for this tileset meta-data
        /// </summary>
        [DataMember(Name = "tagsSourceEnumUid")]
        public int? TagsSourceEnumUid { get; set; }

        [DataMember(Name = "tileGridSize")]
        public int TileGridSize { get; set; }

        /// <summary>
        /// Unique Intidentifier
        /// </summary>
        [DataMember(Name = "uid")]
        public int Uid { get; set; }
    }

    /// <summary>
    /// In a tileset definition, user defined meta-data of a tile.
    /// </summary>
    public partial class TileCustomMetadata
    {
        [DataMember(Name = "data")]
        public string Data { get; set; }

        [DataMember(Name = "tileId")]
        public int TileId { get; set; }
    }

    /// <summary>
    /// In a tileset definition, enum based tag infos
    /// </summary>
    public partial class EnumTagValue
    {
        [DataMember(Name = "enumValueId")]
        public string EnumValueId { get; set; }

        [DataMember(Name = "tileIds")]
        public int[] TileIds { get; set; }
    }

    /// <summary>
    /// This object is not actually used by LDtk. It ONLY exists to force explicit references to
    /// all types, to make sure QuickType finds them and integrate all of them. Otherwise,
    /// Quicktype will drop types that are not explicitely used.
    /// </summary>
    public partial class ForcedRefs
    {
        [IgnoreDataMember]
        [DataMember(Name = "AutoLayerRuleGroup")]
        public AutoLayerRuleGroup AutoLayerRuleGroup { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "AutoRuleDef")]
        public AutoLayerRuleDefinition AutoRuleDef { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "CustomCommand")]
        public LdtkCustomCommand CustomCommand { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "Definitions")]
        public Definitions Definitions { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "EntityDef")]
        public EntityDefinition EntityDef { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "EntityInstance")]
        public EntityInstance EntityInstance { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "EntityReferenceInfos")]
        public ReferenceToAnEntityInstance EntityReferenceInfos { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "EnumDef")]
        public EnumDefinition EnumDef { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "EnumDefValues")]
        public EnumValueDefinition EnumDefValues { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "EnumTagValue")]
        public EnumTagValue EnumTagValue { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "FieldDef")]
        public FieldDefinition FieldDef { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "FieldInstance")]
        public FieldInstance FieldInstance { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "GridPoint")]
        public GridPoint GridPoint { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "IntGridValueDef")]
        public IntGridValueDefinition IntGridValueDef { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "IntGridValueGroupDef")]
        public IntGridValueGroupDefinition IntGridValueGroupDef { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "IntGridValueInstance")]
        public IntGridValueInstance IntGridValueInstance { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "LayerDef")]
        public LayerDefinition LayerDef { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "LayerInstance")]
        public LayerInstance LayerInstance { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "Level")]
        public Level Level { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "LevelBgPosInfos")]
        public LevelBackgroundPosition LevelBgPosInfos { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "NeighbourLevel")]
        public NeighbourLevel NeighbourLevel { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "TableOfContentEntry")]
        public LdtkTableOfContentEntry TableOfContentEntry { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "Tile")]
        public TileInstance Tile { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "TileCustomMetadata")]
        public TileCustomMetadata TileCustomMetadata { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "TilesetDef")]
        public TilesetDefinition TilesetDef { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "TilesetRect")]
        public TilesetRectangle TilesetRect { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "TocInstanceData")]
        public LdtkTocInstanceData TocInstanceData { get; set; }

        [IgnoreDataMember]
        [DataMember(Name = "World")]
        public World World { get; set; }
    }

    public partial class EntityInstance
    {
        /// <summary>
        /// Grid-based coordinates (`[x,y]` format)
        /// </summary>
        [DataMember(Name = "__grid")]
        public int[] Grid { get; set; }

        /// <summary>
        /// Entity definition identifier
        /// </summary>
        [DataMember(Name = "__identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Pivot coordinates  (`[x,y]` format, values are from 0 to 1) of the Entity
        /// </summary>
        [DataMember(Name = "__pivot")]
        public float[] Pivot { get; set; }

        /// <summary>
        /// The entity "smart" color, guessed from either Entity definition, or one its field
        /// instances.
        /// </summary>
        [DataMember(Name = "__smartColor")]
        public string SmartColor { get; set; }

        /// <summary>
        /// Array of tags defined in this Entity definition
        /// </summary>
        [DataMember(Name = "__tags")]
        public string[] Tags { get; set; }

        /// <summary>
        /// Optional TilesetRect used to display this entity (it could either be the default Entity
        /// tile, or some tile provided by a field value, like an Enum).
        /// </summary>
        [DataMember(Name = "__tile")]
        public TilesetRectangle Tile { get; set; }

        /// <summary>
        /// X world coordinate in pixels. Only available in GridVania or Free world layouts.
        /// </summary>
        [DataMember(Name = "__worldX")]
        public int? WorldX { get; set; }

        /// <summary>
        /// Y world coordinate in pixels Only available in GridVania or Free world layouts.
        /// </summary>
        [DataMember(Name = "__worldY")]
        public int? WorldY { get; set; }

        /// <summary>
        /// Reference of the **Entity definition** UID
        /// </summary>
        [DataMember(Name = "defUid")]
        public int DefUid { get; set; }

        /// <summary>
        /// An array of all custom fields and their values.
        /// </summary>
        [DataMember(Name = "fieldInstances")]
        public FieldInstance[] FieldInstances { get; set; }

        /// <summary>
        /// Entity height in pixels. For non-resizable entities, it will be the same as Entity
        /// definition.
        /// </summary>
        [DataMember(Name = "height")]
        public int Height { get; set; }

        /// <summary>
        /// Unique instance identifier
        /// </summary>
        [DataMember(Name = "iid")]
        public string Iid { get; set; }

        /// <summary>
        /// Pixel coordinates (`[x,y]` format) in current level coordinate space. Don't forget
        /// optional layer offsets, if they exist!
        /// </summary>
        [DataMember(Name = "px")]
        public int[] Px { get; set; }

        /// <summary>
        /// Entity width in pixels. For non-resizable entities, it will be the same as Entity
        /// definition.
        /// </summary>
        [DataMember(Name = "width")]
        public int Width { get; set; }
    }

    public partial class FieldInstance
    {
        /// <summary>
        /// Field definition identifier
        /// </summary>
        [DataMember(Name = "__identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Optional TilesetRect used to display this field (this can be the field own Tile, or some
        /// other Tile guessed from the value, like an Enum).
        /// </summary>
        [DataMember(Name = "__tile")]
        public TilesetRectangle Tile { get; set; }

        /// <summary>
        /// Type of the field, such as `Int`, `Float`, `String`, `Enum(my_enum_name)`, `Bool`,
        /// etc.<br/>  NOTE: if you enable the advanced option **Use Multilines type**, you will have
        /// "*Multilines*" instead of "*String*" when relevant.
        /// </summary>
        [DataMember(Name = "__type")]
        public string Type { get; set; }

        /// <summary>
        /// Actual value of the field instance. The value type varies, depending on `__type`:<br/>
        /// - For **classic types** (ie. Integer, Float, Boolean, String, Text and FilePath), you
        /// just get the actual value with the expected type.<br/>   - For **Color**, the value is an
        /// hexadecimal string using "#rrggbb" format.<br/>   - For **Enum**, the value is a String
        /// representing the selected enum value.<br/>   - For **Point**, the value is a
        /// [GridPoint](#ldtk-GridPoint) object.<br/>   - For **Tile**, the value is a
        /// [TilesetRect](#ldtk-TilesetRect) object.<br/>   - For **EntityRef**, the value is an
        /// [EntityReferenceInfos](#ldtk-EntityReferenceInfos) object.<br/><br/>  If the field is an
        /// array, then this `__value` will also be a JSON array.
        /// </summary>
        [DataMember(Name = "__value")]
        public object Value { get; set; }

        /// <summary>
        /// Reference of the **Field definition** UID
        /// </summary>
        [DataMember(Name = "defUid")]
        public int DefUid { get; set; }

        /// <summary>
        /// Editor internal raw values
        /// </summary>
        [DataMember(Name = "realEditorValues")]
        public object[] RealEditorValues { get; set; }
    }

    /// <summary>
    /// This object describes the "location" of an Entity instance in the project worlds.
    ///
    /// IID information of this instance
    /// </summary>
    public partial class ReferenceToAnEntityInstance
    {
        /// <summary>
        /// IID of the refered EntityInstance
        /// </summary>
        [DataMember(Name = "entityIid")]
        public string EntityIid { get; set; }

        /// <summary>
        /// IID of the LayerInstance containing the refered EntityInstance
        /// </summary>
        [DataMember(Name = "layerIid")]
        public string LayerIid { get; set; }

        /// <summary>
        /// IID of the Level containing the refered EntityInstance
        /// </summary>
        [DataMember(Name = "levelIid")]
        public string LevelIid { get; set; }

        /// <summary>
        /// IID of the World containing the refered EntityInstance
        /// </summary>
        [DataMember(Name = "worldIid")]
        public string WorldIid { get; set; }
    }

    /// <summary>
    /// This object is just a grid-based coordinate used in Field values.
    /// </summary>
    public partial class GridPoint
    {
        /// <summary>
        /// X grid-based coordinate
        /// </summary>
        [DataMember(Name = "cx")]
        public int Cx { get; set; }

        /// <summary>
        /// Y grid-based coordinate
        /// </summary>
        [DataMember(Name = "cy")]
        public int Cy { get; set; }
    }

    /// <summary>
    /// IntGrid value instance
    /// </summary>
    public partial class IntGridValueInstance
    {
        /// <summary>
        /// Coordinate ID in the layer grid
        /// </summary>
        [DataMember(Name = "coordId")]
        public int CoordId { get; set; }

        /// <summary>
        /// IntGrid value
        /// </summary>
        [DataMember(Name = "v")]
        public int V { get; set; }
    }

    public partial class LayerInstance
    {
        /// <summary>
        /// Grid-based height
        /// </summary>
        [DataMember(Name = "__cHei")]
        public int CHei { get; set; }

        /// <summary>
        /// Grid-based width
        /// </summary>
        [DataMember(Name = "__cWid")]
        public int CWid { get; set; }

        /// <summary>
        /// Grid size
        /// </summary>
        [DataMember(Name = "__gridSize")]
        public int GridSize { get; set; }

        /// <summary>
        /// Layer definition identifier
        /// </summary>
        [DataMember(Name = "__identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Layer opacity as Float [0-1]
        /// </summary>
        [DataMember(Name = "__opacity")]
        public float Opacity { get; set; }

        /// <summary>
        /// Total layer X pixel offset, including both instance and definition offsets.
        /// </summary>
        [DataMember(Name = "__pxTotalOffsetX")]
        public int PxTotalOffsetX { get; set; }

        /// <summary>
        /// Total layer Y pixel offset, including both instance and definition offsets.
        /// </summary>
        [DataMember(Name = "__pxTotalOffsetY")]
        public int PxTotalOffsetY { get; set; }

        /// <summary>
        /// The definition UID of corresponding Tileset, if any.
        /// </summary>
        [DataMember(Name = "__tilesetDefUid")]
        public int? TilesetDefUid { get; set; }

        /// <summary>
        /// The relative path to corresponding Tileset, if any.
        /// </summary>
        [DataMember(Name = "__tilesetRelPath")]
        public string TilesetRelPath { get; set; }

        /// <summary>
        /// Layer type (possible values: IntGrid, Entities, Tiles or AutoLayer)
        /// </summary>
        [DataMember(Name = "__type")]
        public string Type { get; set; }

        /// <summary>
        /// An array containing all tiles generated by Auto-layer rules. The array is already sorted
        /// in display order (ie. 1st tile is beneath 2nd, which is beneath 3rd etc.).<br/><br/>
        /// Note: if multiple tiles are stacked in the same cell as the result of different rules,
        /// all tiles behind opaque ones will be discarded.
        /// </summary>
        [DataMember(Name = "autoLayerTiles")]
        public TileInstance[] AutoLayerTiles { get; set; }

        [DataMember(Name = "entityInstances")]
        public EntityInstance[] EntityInstances { get; set; }

        [DataMember(Name = "gridTiles")]
        public TileInstance[] GridTiles { get; set; }

        /// <summary>
        /// Unique layer instance identifier
        /// </summary>
        [DataMember(Name = "iid")]
        public string Iid { get; set; }

        /// <summary>
        /// **WARNING**: this deprecated value is no longer exported since version 1.0.0  Replaced
        /// by: `intGridCsv`
        /// </summary>
        [DataMember(Name = "intGrid")]
        public IntGridValueInstance[] IntGrid { get; set; }

        /// <summary>
        /// A list of all values in the IntGrid layer, stored in CSV format (Comma Separated
        /// Values).<br/>  Order is from left to right, and top to bottom (ie. first row from left to
        /// right, followed by second row, etc).<br/>  `0` means "empty cell" and IntGrid values
        /// start at 1.<br/>  The array size is `__cWid` x `__cHei` cells.
        /// </summary>
        [DataMember(Name = "intGridCsv")]
        public int[] IntGridCsv { get; set; }

        /// <summary>
        /// Reference the Layer definition UID
        /// </summary>
        [DataMember(Name = "layerDefUid")]
        public int LayerDefUid { get; set; }

        /// <summary>
        /// Reference to the UID of the level containing this layer instance
        /// </summary>
        [DataMember(Name = "levelId")]
        public int LevelId { get; set; }

        /// <summary>
        /// An Array containing the UIDs of optional rules that were enabled in this specific layer
        /// instance.
        /// </summary>
        [DataMember(Name = "optionalRules")]
        public int[] OptionalRules { get; set; }

        /// <summary>
        /// This layer can use another tileset by overriding the tileset UID here.
        /// </summary>
        [DataMember(Name = "overrideTilesetUid")]
        public int? OverrideTilesetUid { get; set; }

        /// <summary>
        /// X offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added to
        /// the `LayerDef` optional offset, so you should probably prefer using `__pxTotalOffsetX`
        /// which contains the total offset value)
        /// </summary>
        [DataMember(Name = "pxOffsetX")]
        public int PxOffsetX { get; set; }

        /// <summary>
        /// Y offset in pixels to render this layer, usually 0 (IMPORTANT: this should be added to
        /// the `LayerDef` optional offset, so you should probably prefer using `__pxTotalOffsetX`
        /// which contains the total offset value)
        /// </summary>
        [DataMember(Name = "pxOffsetY")]
        public int PxOffsetY { get; set; }

        /// <summary>
        /// Random seed used for Auto-Layers rendering
        /// </summary>
        [DataMember(Name = "seed")]
        public int Seed { get; set; }

        /// <summary>
        /// Layer instance visibility
        /// </summary>
        [DataMember(Name = "visible")]
        public bool Visible { get; set; }
    }

    /// <summary>
    /// This structure represents a single tile from a given Tileset.
    /// </summary>
    public partial class TileInstance
    {
        /// <summary>
        /// Alpha/opacity of the tile (0-1, defaults to 1)
        /// </summary>
        [DataMember(Name = "a")]
        public float A { get; set; }

        /// <summary>
        /// Internal data used by the editor.<br/>  For auto-layer tiles: `[ruleId, coordId]`.<br/>
        /// For tile-layer tiles: `[coordId]`.
        /// </summary>
        [DataMember(Name = "d")]
        public int[] D { get; set; }

        /// <summary>
        /// "Flip bits", a 2-bits integer to represent the mirror transformations of the tile.<br/>
        /// - Bit 0 = X flip<br/>   - Bit 1 = Y flip<br/>   Examples: f=0 (no flip), f=1 (X flip
        /// only), f=2 (Y flip only), f=3 (both flips)
        /// </summary>
        [DataMember(Name = "f")]
        public int F { get; set; }

        /// <summary>
        /// Pixel coordinates of the tile in the **layer** (`[x,y]` format). Don't forget optional
        /// layer offsets, if they exist!
        /// </summary>
        [DataMember(Name = "px")]
        public int[] Px { get; set; }

        /// <summary>
        /// Pixel coordinates of the tile in the **tileset** (`[x,y]` format)
        /// </summary>
        [DataMember(Name = "src")]
        public int[] Src { get; set; }

        /// <summary>
        /// The *Tile ID* in the corresponding tileset.
        /// </summary>
        [DataMember(Name = "t")]
        public int T { get; set; }
    }

    /// <summary>
    /// This section contains all the level data. It can be found in 2 distinct forms, depending
    /// on Project current settings:  - If "*Separate level files*" is **disabled** (default):
    /// full level data is *embedded* inside the main Project JSON file, - If "*Separate level
    /// files*" is **enabled**: level data is stored in *separate* standalone `.ldtkl` files (one
    /// per level). In this case, the main Project JSON file will still contain most level data,
    /// except heavy sections, like the `layerInstances` array (which will be null). The
    /// `externalRelPath` string points to the `ldtkl` file.  A `ldtkl` file is just a JSON file
    /// containing exactly what is described below.
    /// </summary>
    public partial class Level
    {
        /// <summary>
        /// Background color of the level (same as `bgColor`, except the default value is
        /// automatically used here if its value is `null`)
        /// </summary>
        [DataMember(Name = "__bgColor")]
        public string BgColor { get; set; }

        /// <summary>
        /// Position informations of the background image, if there is one.
        /// </summary>
        [DataMember(Name = "__bgPos")]
        public LevelBackgroundPosition BgPos { get; set; }

        /// <summary>
        /// An array listing all other levels touching this one on the world map. Since 1.4.0, this
        /// includes levels that overlap in the same world layer, or in nearby world layers.<br/>
        /// Only relevant for world layouts where level spatial positioning is manual (ie. GridVania,
        /// Free). For Horizontal and Vertical layouts, this array is always empty.
        /// </summary>
        [DataMember(Name = "__neighbours")]
        public NeighbourLevel[] Neighbours { get; set; }

        /// <summary>
        /// The "guessed" color for this level in the editor, decided using either the background
        /// color or an existing custom field.
        /// </summary>
        [DataMember(Name = "__smartColor")]
        public string SmartColor { get; set; }

        /// <summary>
        /// Background color of the level. If `null`, the project `defaultLevelBgColor` should be
        /// used.
        /// </summary>
        [DataMember(Name = "bgColor")]
        public string LevelBgColor { get; set; }

        /// <summary>
        /// Background image X pivot (0-1)
        /// </summary>
        [DataMember(Name = "bgPivotX")]
        public float BgPivotX { get; set; }

        /// <summary>
        /// Background image Y pivot (0-1)
        /// </summary>
        [DataMember(Name = "bgPivotY")]
        public float BgPivotY { get; set; }

        /// <summary>
        /// An enum defining the way the background image (if any) is positioned on the level. See
        /// `__bgPos` for resulting position info. Possible values: &lt;`null`&gt;, `Unscaled`,
        /// `Contain`, `Cover`, `CoverDirty`, `Repeat`
        /// </summary>
        [DataMember(Name = "bgPos")]
        public BgPos? LevelBgPos { get; set; }

        /// <summary>
        /// The *optional* relative path to the level background image.
        /// </summary>
        [DataMember(Name = "bgRelPath")]
        public string BgRelPath { get; set; }

        /// <summary>
        /// This value is not null if the project option "*Save levels separately*" is enabled. In
        /// this case, this **relative** path points to the level Json file.
        /// </summary>
        [DataMember(Name = "externalRelPath")]
        public string ExternalRelPath { get; set; }

        /// <summary>
        /// An array containing this level custom field values.
        /// </summary>
        [DataMember(Name = "fieldInstances")]
        public FieldInstance[] FieldInstances { get; set; }

        /// <summary>
        /// User defined unique identifier
        /// </summary>
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Unique instance identifier
        /// </summary>
        [DataMember(Name = "iid")]
        public string Iid { get; set; }

        /// <summary>
        /// An array containing all Layer instances. **IMPORTANT**: if the project option "*Save
        /// levels separately*" is enabled, this field will be `null`.<br/>  This array is **sorted
        /// in display order**: the 1st layer is the top-most and the last is behind.
        /// </summary>
        [DataMember(Name = "layerInstances")]
        public LayerInstance[] LayerInstances { get; set; }

        /// <summary>
        /// Height of the level in pixels
        /// </summary>
        [DataMember(Name = "pxHei")]
        public int PxHei { get; set; }

        /// <summary>
        /// Width of the level in pixels
        /// </summary>
        [DataMember(Name = "pxWid")]
        public int PxWid { get; set; }

        /// <summary>
        /// Unique Int identifier
        /// </summary>
        [DataMember(Name = "uid")]
        public int Uid { get; set; }

        /// <summary>
        /// If TRUE, the level identifier will always automatically use the naming pattern as defined
        /// in `Project.levelNamePattern`. Becomes FALSE if the identifier is manually modified by
        /// user.
        /// </summary>
        [DataMember(Name = "useAutoIdentifier")]
        public bool UseAutoIdentifier { get; set; }

        /// <summary>
        /// Index that represents the "depth" of the level in the world. Default is 0, greater means
        /// "above", lower means "below".<br/>  This value is mostly used for display only and is
        /// intended to make stacking of levels easier to manage.
        /// </summary>
        [DataMember(Name = "worldDepth")]
        public int WorldDepth { get; set; }

        /// <summary>
        /// World X coordinate in pixels.<br/>  Only relevant for world layouts where level spatial
        /// positioning is manual (ie. GridVania, Free). For Horizontal and Vertical layouts, the
        /// value is always -1 here.
        /// </summary>
        [DataMember(Name = "worldX")]
        public int WorldX { get; set; }

        /// <summary>
        /// World Y coordinate in pixels.<br/>  Only relevant for world layouts where level spatial
        /// positioning is manual (ie. GridVania, Free). For Horizontal and Vertical layouts, the
        /// value is always -1 here.
        /// </summary>
        [DataMember(Name = "worldY")]
        public int WorldY { get; set; }
    }

    /// <summary>
    /// Level background image position info
    /// </summary>
    public partial class LevelBackgroundPosition
    {
        /// <summary>
        /// An array of 4 float values describing the cropped sub-rectangle of the displayed
        /// background image. This cropping happens when original is larger than the level bounds.
        /// Array format: `[ cropX, cropY, cropWidth, cropHeight ]`
        /// </summary>
        [DataMember(Name = "cropRect")]
        public float[] CropRect { get; set; }

        /// <summary>
        /// An array containing the `[scaleX,scaleY]` values of the **cropped** background image,
        /// depending on `bgPos` option.
        /// </summary>
        [DataMember(Name = "scale")]
        public float[] Scale { get; set; }

        /// <summary>
        /// An array containing the `[x,y]` pixel coordinates of the top-left corner of the
        /// **cropped** background image, depending on `bgPos` option.
        /// </summary>
        [DataMember(Name = "topLeftPx")]
        public int[] TopLeftPx { get; set; }
    }

    /// <summary>
    /// Nearby level info
    /// </summary>
    public partial class NeighbourLevel
    {
        /// <summary>
        /// A single lowercase character tipping on the level location (`n`orth, `s`outh, `w`est,
        /// `e`ast).<br/>  Since 1.4.0, this character value can also be `<` (neighbour depth is
        /// lower), `>` (neighbour depth is greater) or `o` (levels overlap and share the same world
        /// depth).
        /// </summary>
        [DataMember(Name = "dir")]
        public string Dir { get; set; }

        /// <summary>
        /// Neighbour Instance Identifier
        /// </summary>
        [DataMember(Name = "levelIid")]
        public string LevelIid { get; set; }

        /// <summary>
        /// **WARNING**: this deprecated value is no longer exported since version 1.2.0  Replaced
        /// by: `levelIid`
        /// </summary>
        [DataMember(Name = "levelUid")]
        public int? LevelUid { get; set; }
    }

    public partial class LdtkTableOfContentEntry
    {
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// **WARNING**: this deprecated value will be *removed* completely on version 1.7.0+
        /// Replaced by: `instancesData`
        /// </summary>
        [IgnoreDataMember]
        [DataMember(Name = "instances")]
        public ReferenceToAnEntityInstance[] Instances { get; set; }

        [DataMember(Name = "instancesData")]
        public LdtkTocInstanceData[] InstancesData { get; set; }
    }

    public partial class LdtkTocInstanceData
    {
        /// <summary>
        /// An object containing the values of all entity fields with the `exportToToc` option
        /// enabled. This object typing depends on actual field value types.
        /// </summary>
        [DataMember(Name = "fields")]
        public object Fields { get; set; }

        [DataMember(Name = "heiPx")]
        public int HeiPx { get; set; }

        /// <summary>
        /// IID information of this instance
        /// </summary>
        [DataMember(Name = "iids")]
        public ReferenceToAnEntityInstance Iids { get; set; }

        [DataMember(Name = "widPx")]
        public int WidPx { get; set; }

        [DataMember(Name = "worldX")]
        public int WorldX { get; set; }

        [DataMember(Name = "worldY")]
        public int WorldY { get; set; }
    }

    /// <summary>
    /// **IMPORTANT**: this type is available as a preview. You can rely on it to update your
    /// importers, for when it will be officially available.  A World contains multiple levels,
    /// and it has its own layout settings.
    /// </summary>
    public partial class World
    {
        /// <summary>
        /// Default new level height
        /// </summary>
        [DataMember(Name = "defaultLevelHeight")]
        public int DefaultLevelHeight { get; set; }

        /// <summary>
        /// Default new level width
        /// </summary>
        [DataMember(Name = "defaultLevelWidth")]
        public int DefaultLevelWidth { get; set; }

        /// <summary>
        /// User defined unique identifier
        /// </summary>
        [DataMember(Name = "identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Unique instance identifer
        /// </summary>
        [DataMember(Name = "iid")]
        public string Iid { get; set; }

        /// <summary>
        /// All levels from this world. The order of this array is only relevant in
        /// `LinearHorizontal` and `linearVertical` world layouts (see `worldLayout` value).
        /// Otherwise, you should refer to the `worldX`,`worldY` coordinates of each Level.
        /// </summary>
        [DataMember(Name = "levels")]
        public Level[] Levels { get; set; }

        /// <summary>
        /// Height of the world grid in pixels.
        /// </summary>
        [DataMember(Name = "worldGridHeight")]
        public int WorldGridHeight { get; set; }

        /// <summary>
        /// Width of the world grid in pixels.
        /// </summary>
        [DataMember(Name = "worldGridWidth")]
        public int WorldGridWidth { get; set; }

        /// <summary>
        /// An enum that describes how levels are organized in this project (ie. linearly or in a 2D
        /// space). Possible values: `Free`, `GridVania`, `LinearHorizontal`, `LinearVertical`, `null`
        /// </summary>
        [DataMember(Name = "worldLayout")]
        public WorldLayout? WorldLayout { get; set; }
    }

    /// <summary>
    /// Possible values: `Manual`, `AfterLoad`, `BeforeSave`, `AfterSave`
    /// </summary>
    public enum When { AfterLoad, AfterSave, BeforeSave, Manual };

    /// <summary>
    /// Possible values: `Any`, `OnlySame`, `OnlyTags`, `OnlySpecificEntity`
    /// </summary>
    public enum AllowedRefs { Any, OnlySame, OnlySpecificEntity, OnlyTags };

    /// <summary>
    /// Possible values: `Hidden`, `ValueOnly`, `NameAndValue`, `EntityTile`, `LevelTile`,
    /// `Points`, `PointStar`, `PointPath`, `PointPathLoop`, `RadiusPx`, `RadiusGrid`,
    /// `ArrayCountWithLabel`, `ArrayCountNoLabel`, `RefLinkBetweenPivots`,
    /// `RefLinkBetweenCenters`
    /// </summary>
    public enum EditorDisplayMode { ArrayCountNoLabel, ArrayCountWithLabel, EntityTile, Hidden, LevelTile, NameAndValue, PointPath, PointPathLoop, PointStar, Points, RadiusGrid, RadiusPx, RefLinkBetweenCenters, RefLinkBetweenPivots, ValueOnly };

    /// <summary>
    /// Possible values: `Above`, `Center`, `Beneath`
    /// </summary>
    public enum EditorDisplayPos { Above, Beneath, Center };

    /// <summary>
    /// Possible values: `ZigZag`, `StraightArrow`, `CurvedArrow`, `ArrowsLine`, `DashedLine`
    /// </summary>
    public enum EditorLinkStyle { ArrowsLine, CurvedArrow, DashedLine, StraightArrow, ZigZag };

    public enum TextLanguageMode { LangC, LangHaxe, LangJs, LangJson, LangLog, LangLua, LangMarkdown, LangPython, LangRuby, LangXml };

    /// <summary>
    /// Possible values: `DiscardOldOnes`, `PreventAdding`, `MoveLastOne`
    /// </summary>
    public enum LimitBehavior { DiscardOldOnes, MoveLastOne, PreventAdding };

    /// <summary>
    /// If TRUE, the maxCount is a "per world" limit, if FALSE, it's a "per level". Possible
    /// values: `PerLayer`, `PerLevel`, `PerWorld`
    /// </summary>
    public enum LimitScope { PerLayer, PerLevel, PerWorld };

    /// <summary>
    /// Possible values: `Rectangle`, `Ellipse`, `Tile`, `Cross`
    /// </summary>
    public enum RenderMode { Cross, Ellipse, Rectangle, Tile };

    /// <summary>
    /// An enum describing how the the Entity tile is rendered inside the Entity bounds. Possible
    /// values: `Cover`, `FitInside`, `Repeat`, `Stretch`, `FullSizeCropped`,
    /// `FullSizeUncropped`, `NineSlice`
    /// </summary>
    public enum TileRenderMode { Cover, FitInside, FullSizeCropped, FullSizeUncropped, NineSlice, Repeat, Stretch };

    /// <summary>
    /// Checker mode Possible values: `None`, `Horizontal`, `Vertical`
    /// </summary>
    public enum Checker { Horizontal, None, Vertical };

    /// <summary>
    /// Defines how tileIds array is used Possible values: `Single`, `Stamp`
    /// </summary>
    public enum TileMode { Single, Stamp };

    /// <summary>
    /// Type of the layer as Haxe Enum Possible values: `IntGrid`, `Entities`, `Tiles`,
    /// `AutoLayer`
    /// </summary>
    public enum TypeEnum { AutoLayer, Entities, IntGrid, Tiles };

    public enum EmbedAtlas { LdtkIcons };

    public enum Flag { DiscardPreCsvIntGrid, ExportOldTableOfContentData, ExportPreCsvIntGridFormat, IgnoreBackupSuggest, MultiWorlds, PrependIndexToLevelFileNames, UseMultilinesType };

    public enum BgPos { Contain, Cover, CoverDirty, Repeat, Unscaled };

    public enum WorldLayout { Free, GridVania, LinearHorizontal, LinearVertical };

    /// <summary>
    /// Naming convention for Identifiers (first-letter uppercase, full uppercase etc.) Possible
    /// values: `Capitalize`, `Uppercase`, `Lowercase`, `Free`
    /// </summary>
    public enum IdentifierStyle { Capitalize, Free, Lowercase, Uppercase };

    /// <summary>
    /// "Image export" option when saving project. Possible values: `None`, `OneImagePerLayer`,
    /// `OneImagePerLevel`, `LayersAndLevels`
    /// </summary>
    public enum ImageExportMode { LayersAndLevels, None, OneImagePerLayer, OneImagePerLevel };

    public partial class LdtkJson
    {
        public static LdtkJson FromJson(string json) => JsonSerializer.Deserialize<LdtkJson>(json);
    }

    public static class Serialize
    {
        public static byte[] ToJson(this LdtkJson self) => JsonSerializer.Serialize(self);
    }
}
